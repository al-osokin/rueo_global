# Этап 2: Реализация полнотекстового поиска

**Цель:** Предоставить пользователям возможность поиска по всему тексту словарных статей.

### Сделано

- Настроен поток ревью переводов: группы получают несколько гипотез, UI позволяет выбирать нужную, а выбранные варианты возвращаются в парсер и снимают автоматический `needs_review`.
- Исправлен автодополнитель `suggest` — теперь ищет без учёта регистра, так что мобильный ввод с заглавной буквы не ломает результаты.
- Починен разбор скобок с `_или_` в переводах (например, `[abi/(o)/pice/o]`), генерация развёрнутых комбинаций формирует корректные синонимы.
- Перегенерированы все статьи эсперанто-русского словаря (46350 шт.) после правок парсера, состояния обновлены в `article_parse_state`.

### Что дальше

- Продолжить нормализацию переводов для полнотекста: доработать раскрытие списков и суффиксов, затем заполнить `full_text_content`.
- После подготовки текста — реализовать шаги 2.1–2.4 (индексация, API и фронт) по основному плану ниже.

### Заметки 2025-10-20

- Письма с Ctrl+Enter теперь уходят через `/orph` в FastAPI: отправка выполняется по SMTP (настройки берём из `SMTP_*`, логируем в `backend/data/logs`), PHP-скрипты из `public/` удалены.
- Импорт читает `RUEO_DATA_DIR`, благодаря чему dev/prod могут держать исходники в разных каталогах.
- Разбор `[abort|i]` и похожих статей улучшен: сбрасываем буфер при нумерованных пунктах, подтягиваем содержимое дочерних узлов, склеиваем соседние текстовые сегменты и корректно обрабатываем пометы `т.е.` (после этого группы формируются как `абортивный | недоношенный | …`, `остановиться в развитии | окончиться провалом | потерпеть неудачу`, и т.д.).
- `parse_articles` теперь в JSON-отчёте разделяет успешные/проваленные статьи; при необходимости можно быстро посмотреть, что осталось без headword.
- Добавлена кнопка «Сбросить» на карточке админки и бекенд-эндпоинт `/admin/articles/{lang}/{art_id}/reset` — очищает `resolved_translations`, повторно парсит статью и сразу возвращает свежие варианты.
- Есть сервисная кнопка «Переразобрать проблемные» (фронт + `/admin/articles/{lang}/reparse`), умеет переобработать статьи `needs_review` и, при флажке, `pending`.
- Импорт снова выполняется «с нуля» (очистка таблиц), так что дубли статей и устаревшие заголовки в БД исчезли.
- Актуальный парсер по части комбинаций и пояснений:
  * `_т.е._` теперь отбрасывается, если служебное, без перестановки строки; базовый список соответствует расширенному.
  * `аборт`ивный (при)остан`авливающий развитие → `аборт`ивный | приостан`авливающий развитие | останавливающий развитие.
  * `аборт`ивное средство; _ист._ аборт`ивный кес`арий → `аборт`ивное средство | аборт`ивный кес`арий`.

### Шаг 2.1: Подготовка данных для индексации

- **2.1.1.** Создать в таблице `artikoloj` новое текстовое поле, например, `full_text_content`.
- **2.1.2.** Доработать Python-импортер (из Этапа 1), добавив в него функцию "нормализации" текста для поиска:
    - Замена тильды (`~`) на соответствующую часть заголовочного слова.
    - Раскрытие синонимов, записанных через запятую (`страстно, горячо любить` -> `страстно любить, горячо любить`).
- **2.1.3.** Добавить в импортера конвертацию сокращений и помет (например, `(любовное) увлечение` -> `любовное увлечение, увлечение`).
- **2.1.4.** Удалять ударения и специальные знаки (`'`, `` ` ``, `^`), оставляя только буквенно-цифровые символы.

### Шаг 2.2: Настройка полнотекстового индекса

- **2.2.1.** В PostgreSQL использовать `GIN`-индекс по `to_tsvector('russian', full_text_content)` и отдельный индекс для эсперанто (возможно на основе `simple` словаря).
- **2.2.2.** Настроить лексемы и поиск с учетом `ё/е`, `ĉ/cx` и т.п.
- **2.2.3.** Провести тестирование запросов и сравнить результаты со старым сайтом.

### Шаг 2.3: API для полнотекстового поиска

- **2.3.1.** Создать эндпоинт `/api/search/full-text`, принимающий поисковую строку и язык.
- **2.3.2.** Эндпоинт должен возвращать:
    - Список совпадений с кратким фрагментом (snippet).
    - Ссылку на статью (`/sercxo/{id}`).
    - Вес совпадения (релевантность).
- **2.3.3.** Предусмотреть параметры:
    - фильтр по языку (`eo`, `ru`);
    - пагинация;
    - сортировка (по релевантности или алфавиту).

### Шаг 2.4: Интеграция на фронтенде

- **2.4.1.** Добавить в `rueo_fronto` отдельную страницу (или режим), где поисковая строка выполняет полнотекстовый запрос.
- **2.4.2.** Реализовать отображение сниппетов с подсветкой совпадений.
- **2.4.3.** Добавить фильтры (по языку, типу результата).

### Шаг 2.5: Тестирование и мониторинг

- **2.5.1.** Сравнить выборку результатов со старым поиском, удостовериться в отсутствии регрессий.
- **2.5.2.** Настроить логирование полнотекстовых запросов (новая таблица или расширение `statistiko`).
- **2.5.3.** Подготовить документацию по использованию API и обновить проектную память.


### Дополнительно: корпус документов для поиска

- Помимо словаря, включаем в полнотекстовый индекс грамматический очерк: тексты сейчас в Vue-компонентах (`References/rueo_fronto/src/components/gram`); исходники в markdown/textile лежат в `References/old.rueo.ru/tekstoj/grammatika*.textile`. При расхождении источников приоритет у `.vue` (самые свежие правки).
- План: перевести грамматический корпус в Markdown (для редактирования через VS Code), использовать уже подключённый markdown-плагин на фронте, а нормализованный текст загружать в общую таблицу документов (типы: словарь, грамматика, новости и т.п.).
- Нормализацию делаем инкрементальной: после контроля checksum перерабатываем только статьи/документы, которые изменились; результаты складываем в отдельную таблицу (например, `article_texts`) и строим GIN-индексы `tsvector` по каждому языку.
- Используем полнотекстовый поиск PostgreSQL (без ElasticSearch) — достаточно для текущей нагрузки; в будущем можно рассмотреть внешний движок при необходимости.

- Перед выкладкой обновлённой версии на прод проверяли отправку сообщений (Ctrl+Enter) — работает и в dev, и на prod rueo.ru.

### Черновые заметки по парсеру v3

- `translation` складывается из узлов `content`: `label`, `text`, `divider`. Комбинация запятой и точки с запятой → `ru_requires_review` + оригинал в `meta.raw_ru_text`.
- Внутри курсивных вставок (`_или_`, `_ср._` и т.д.) не собираем пары `eo/ru`; курсив остаётся отдельным узлом.
- Иллюстрации (`illustration`) пока хранят `ru_segments`; для полнотекста надо привести их к тем же сегментам, что и `translation`.
- Скобочные варианты (`заранее (_или_ заблаговременно)`) разворачиваем и подтягиваем к ближайшему глаголу: `заранее позаботиться`, `заблаговременно позаботиться`, `предусмотреть`. Для последовательностей вида `выполнить (_или_ совершить) заранее, досрочно, предварительно` строим декартовы комбинации (`выполнить досрочно`, `совершить предварительно`). Аналогичные расширения применяем к схемам «прилагательные + общее существительное» и «глаголы + общее наречие»: пары создаются автоматически, но статьи всё равно помечаются для ревью.
- Примеры (`illustration`) разбираем так же, как переводы: секция хранит исходный пример (`~a naĝilo`), хвосты раскладываются в комбинации; служебные слова типа `см.`/знаки пунктуации отбрасываем.
- На перспективу: закрыть админку авторизацией и предусмотреть подключение добровольцев — раздавать небольшие задания и принимать решение по большинству ответов (например, три совпавших).
- При повторе общего слова (например, `прежние события, прежние поступки`) формируем словосочетания целиком — в индексе лежат развёрнутые строки.

### Админка обратной связи (план)

1. **API**
   - `GET /api/admin/articles/{lang}?query=...` — автокомплит по заголовку, возвращает `art_id`, лемму, статус.
   - `GET /api/admin/articles/{lang}/{art_id}` — карточка: шаблон, словоформы, группы переводов (авто-кандидаты + флаги `ru_requires_review`), история заметок.
   - `POST /api/admin/articles/{lang}/{art_id}` — сохраняет подтверждённые варианты и комментарии, возвращает ID следующей статьи.
   - Таблица `article_parse_notes`: `id`, `lang`, `art_id`, `author`, `body`, `created_at`.

2. **UI**
   - Поиск по началу слова, список совпадений.
   - Карточка статьи: дерево словоформ (подсветка проблем), блоки переводов с выбором вариантов и отображением автогенерации, блок «переписка».
   - Навигация «предыдущая/следующая» и кнопка «сохранить и перейти дальше».

3. **Сохранение**
   - В `article_parse_state` добавляем JSON `resolved_translations` и флаг `has_notes`.
   - При сохранении обновляем состояние и создаём запись в `article_parse_notes`.

4. **На будущее**
   - После внедрения цветного рендера отдаём через API `source_html`, фронт переиспользует текущую структуру.
